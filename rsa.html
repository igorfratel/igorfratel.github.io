<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Igor Fratel's homepage</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/3/w3.css">
        <link rel="stylesheet" type="text/css" href="main.css">
    </head>
    <body>
        <!-- Navigation -->
        <nav class="w3-bar w3-pink">
            <a href="index.html" class="w3-button w3-bar-item w3-hover-white w3-round">Home</a>
            <a href="aboutme.html" class="w3-button w3-bar-item w3-hover-white w3-round">About Me</a>
            <a href="projects.html" class="w3-button w3-bar-item w3-hover-white w3-round">Projects</a>
            <a href="posts.html" class="w3-button w3-bar-item w3-hover-white w3-round">Posts</a>
            <a href="sources.html" class="w3-button w3-bar-item w3-hover-white w3-round">Sources</a>
        </nav>
        <nav class="w3-panel w3-light-gray w3-text-dark-gray">
            <h2>Método de criptografia RSA</h2>
            <p>
                Sejam:<br>
                \(T\) uma tabela que associa de forma não ambígua cada letra do alfabeto a um número natural,<br>
                \(M\) nossa mensagem a ser criptografada,<br>
                \(p\) e \(q\) dois números primos grandes,<br>
                \(\lambda\) um número inteiro.<br><br>

                Regra de codificação:<br>
                Queremos codificar \(M\) de forma a obter uma mensagem secreta \(S\).<br>
                Primeiro aplicamos a tabela \(T\) a \(M\), obtendo um conjunto de números \(N\).<br>
                Agora, dividiremos \(N\) em blocos de dígitos, onde cada bloco deve ser menor ou igual a \(p*q\), que é
                a nossa chave de codificação.<br>
                Por exemplo, se \(N = 234050375\), \(p=5\) e \(q=7\), podemos dividir N em blocos:<br>
                [23, 40, 50, 3, 7, 5]<br>
                Mas não em blocos:<br>
                [23, 40, 503, 75]<br>
                Pois cada bloco não pode ser maior que \(p*q=35\)<br>
                Para cada bloco \(b\) de \(N\), aplicaremos \(b^\lambda(modp*q)\), gerando blocos \(b'\).<br>
                Nossa mensagem codificada \(S\) é formada pela junção de todos os blocos \(b'\).<br>
                Resumindo: \(b^\lambda \equiv b' (mod p*q)\).<br><br>

                Regra de decodificação:<br>
                Temos a mensagem criptografada \(S\) e os blocos \(b'\) que a compõem e
                queremos recuperar a mensagem original \(M\).<br>
                Para cada \(b'\), vamos aplicar \(b'^d(modp*q)\), onde \(d\) é a chave de decodificação,
                gerando blocos \(b\).<br>
                A chave de decodificação \(d\) é o inverso multiplicativo de \(\lambda\) módulo \((p-1)*(q-1)\), ou seja,
                é o número \(d\) tal que \(d*\lambda \equiv 1(mod(p-1)*(q-1))\).<br>
                Tendo os blocos \(b\), obtemos o conjunto de números \(N\), do qual podemos extrair a mensagem
                \(M\) utilizando a tabela \(T\).<br>
                Resumindo \(b'^d \equiv b(modp*q)\).<br><br>

                Observações práticas:<br>
                Dependendo do \(\lambda\) escolhido, pode ser que não exista um número \(d\) que seja seu inverso
                módulo \((p-1)*(q-1)\), tornando a decodificação da mensagem impossível.<br>
                Por exemplo, quando \(\lambda\) é par, não existirá tal \(d\), pois \((p-1)*(q-1)\) sempre será par
                e o teorema da existência do inverso modular diz que "\(a\) tem classe inversa módulo
                \(n\) sse \(mdc(a,n)=1\)".<br>
                Ou seja, para existir \(d\), \(\lambda\) deverá ser coprimo com \((p-1)*(q-1)\), o que não acontece se
                os dois são pares.<br>
                Por convenção \(lambda\) é sempre escolhido como sendo o número \(3\) e tanto \(p\) quanto \(q\) devem
                ser congruentes a \(5\) módulo \(6\).<br><br>

                Por que \(p\) e \(q\) devem ser \(\equiv 5(mod6)\)?:<br>
                Isso garante que haverá um \(d\) tal que \(d*\lambda \equiv 1(mod(p-1)*(q-1))\)<br>
                quando \(\lambda=3\).<br>
                Prova:<br>
                Temos<br>
                \(p \equiv 5(mod6)\)<br>
                \(q \equiv 5(mod6)\)<br>
                Portanto<br>
                \(p-1 \equiv 4(mod6)\)<br>
                \(q-1 \equiv 4(mod6)\)<br>
                \((p-1)(q-1) \equiv 4*4(mod6)\)<br>
                \((p-1)(q-1) \equiv 16 \equiv 4(mod6)\)<br>
                \((p-1)(q-1) = 6k + 4\), \(k \in \mathbb{Z}\), pela definição de congruência modular.<br>
                \((p-1)(q-1) = 6k + 3 + 1\)<br>
                \((p-1)(q-1) = 3(2k + 1) + 1\)<br>
                \((p-1)(q-1) - 1 = 3(2k + 1)\)<br>
                \(3(2k+1) \equiv -1(mod(p-1)(q-1))\)<br>
                \(3(-2k-1) \equiv 1(mod(p-1)(q-1))\)<br>
                \(3(4k+3) \equiv 1(mod(p-1)(q-1))\), pois como \((p-1)(q-1)=6k+4\), podemos somar \(6k+4\) a \(-2k-1\)
                e ainda mantemos a congruência modular.<br>
                Ou seja, existe o inverso modular \(d\) e ele é igual a \(4k+3\) onde
                \(k = \frac{(p-1)(q-1)-4}{6}\).<br><br>

                Próximo post: <a style="text-decoration:underline" href="rsafuncionamento.html"> Por que o RSA funciona? </a>
                <br>
                <br>
                <br>
            </p>
        </nav>

        <div class="footer w3-red"> <h3>Made with ♥</h3></div>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
              CommonHTML: { linebreaks: { automatic: true } },
              "HTML-CSS": { linebreaks: { automatic: true } },
                     SVG: { linebreaks: { automatic: true } }
            });
        </script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    </body>
</html>
